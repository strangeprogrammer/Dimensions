//Test string: (aA>zA<)(&F#F~F@)(#~@)(0987654321+)(0-)(%)(Â£)($)([)([)([)(1-)(])(])(])([)(])(/)

/*
Invoke parser with:
Parser parser;
parser.parse();
*/

%scanner "flexcpp/Scanner.hpp"
%default-actions std

%token LPAREN RPAREN MFORE MBACK VSTORE VFORE VBACK VZERO PLUS MINUS INASCII OUTNUM OUTASCII WHILE ENDWHILE NOOP NUMBER LETTER
%start commands

%union {
	ExecBlocks::Instruction*	INST;
	Details::Axes*			AXES;
	Details::Number*		NUM;
	bool				BOOL;
}
%type <INST> action enclosed nonenclosed motion store_velocity literal_velocity arithmetic
%type <AXES> velocity letters
%type <NUM> numeric
%type <BOOL> polarity

%%
commands
: commands command
| /*empty*/
;

command
: action {
	Globals::env.append($1);
}
| WHILE {
	using namespace std;
	Globals::env.append(new ExecBlocks::tzj());
	Globals::env.jpush();
} commands ENDWHILE {
	using namespace std;
	Globals::env.append(new ExecBlocks::jmp());
	Globals::env.jpop();
}
;

action
: enclosed
| LPAREN nonenclosed RPAREN {
	$$=$2;
}
;

enclosed
: INASCII {
	$$=new ExecBlocks::getc();
}
| OUTNUM {
	$$=new ExecBlocks::putn();
}
| OUTASCII {
	$$=new ExecBlocks::putc();
}
| NOOP {
	$$=new ExecBlocks::noop();
}
;

nonenclosed
: motion
| store_velocity
| literal_velocity
| arithmetic
;

motion
: letters MFORE letters MBACK {
	KVP<unsigned long,long>* temp;
	while(temp=$3->rmrandom()){
		$1->set(temp->key,-1);
		delete temp;
	}
	delete $3;
	$$=new ExecBlocks::mov($1);
}
;

store_velocity
: VSTORE velocity {
	$$=new ExecBlocks::strv($2);
}
;

literal_velocity
: velocity {
	$$=new ExecBlocks::setv($1);
}
;

velocity
: letters VFORE letters VBACK letters VZERO {
	KVP<unsigned long,long>* temp;
	while(temp=$3->rmrandom()){
		$1->set(temp->key,-1);
		delete temp;
	}
	delete $3;
	while(temp=$5->rmrandom()){
		$1->set(temp->key,0);
		delete temp;
	}
	delete $5;
	$$=$1;
}
;

letters
: letters LETTER {
	$1->set(d_scanner.matched()[0],1);
	$$=$1;
}
| /*empty*/ {
	$$=new Details::Axes();
}
;

arithmetic
: numeric polarity {
	if($2){
		$$=new ExecBlocks::add($1);
	}else{
		$$=new ExecBlocks::sub($1);
	}
}
;

numeric
: NUMBER {
	$$=new Details::Number(std::stol(d_scanner.matched(),NULL,10));
}
;

polarity
: PLUS {
	$$=true;
}
| MINUS {
	$$=false;
}
;
